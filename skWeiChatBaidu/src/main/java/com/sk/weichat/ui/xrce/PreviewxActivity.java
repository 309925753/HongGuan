package com.sk.weichat.ui.xrce;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.graphics.Bitmap;import android.media.MediaMetadataRetriever;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.text.TextUtils;import android.util.Log;import android.view.View;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.RelativeLayout;import android.widget.TextView;import android.widget.Toast;import com.sk.weichat.R;import com.sk.weichat.broadcast.MsgBroadcast;import com.sk.weichat.helper.AvatarHelper;import com.sk.weichat.helper.CutoutHelper;import com.sk.weichat.helper.DialogHelper;import com.sk.weichat.helper.ImageLoadHelper;import com.sk.weichat.ui.base.BaseActivity;import com.sk.weichat.ui.trill.MarqueTextView;import com.sk.weichat.ui.trill.ReleasexActivity;import com.sk.weichat.util.AsyncUtils;import com.sk.weichat.util.DisplayUtil;import com.sk.weichat.util.FastBlurUtil;import com.sk.weichat.util.FileUtil;import com.sk.weichat.util.RecorderUtils;import com.sk.weichat.util.ToastUtil;import com.sk.weichat.util.VideoCompressUtil;import java.io.File;import Jni.VideoUitls;import VideoHandle.EpDraw;import VideoHandle.EpEditor;import VideoHandle.EpVideo;import VideoHandle.OnEditorListener;import fm.jiecao.jcvideoplayer_lib.JCVideoPlayer;import fm.jiecao.jcvideoplayer_lib.JCVideoViewbyXuan;import fm.jiecao.jcvideoplayer_lib.OnJcvdListener;public class PreviewxActivity extends BaseActivity implements View.OnClickListener {    BroadcastReceiver closeReceiver = new BroadcastReceiver() {        @Override        public void onReceive(Context context, Intent intent) {            finish();        }    };    private String mCurrPath; // 当前的视屏    private String mVideoPath; // 原版视屏    private JCVideoViewbyXuan mVideoView;    private RelativeLayout mRlTop;    private RelativeLayout mRlBottom;    private LinearLayout mWaitDialog;    private Xspeedbar mSpeedBar;    private MarqueTextView mTvBgmName;    private String mCurrBgmName;    private Xvolumebar mVolumeBar;    private SelectMusicDialog mSelectDialog;    private String mCurrBgmPath;    private TextView mTvLoding;    private String mHitText;    private ImageView mAvatarImg;    private ImageView iv_thumb;    private String thumbPath;    private String mCoverPath;    private SelectCoverDialog coverDialog;    private int loadCover;    private Xpreprogressbar progressbar;    private String mCurrBgmId;    Handler handler = new Handler(new Handler.Callback() {        @Override        public boolean handleMessage(Message msg) {            switch (msg.what) {                case RecorderUtils.COVER_SUCCESS:                    // 获取封面成功                    if (loadCover == RecorderUtils.COVER_SUCCESS) {                        coverDialog.show(mCoverPath);                        mVideoView.pause();                        iv_thumb.setVisibility(View.VISIBLE);                    }                    loadCover = RecorderUtils.COVER_SUCCESS;                    break;                case RecorderUtils.COVER_FAILURE: // 获取封面失败                    findViewById(R.id.ll_cover).setVisibility(View.GONE);                    break;                case RecorderUtils.COMPRESS_SUCCESS: // 压缩成功                    Log.e("xuan", "压缩成功" + mCurrPath);                    showWaitDialog(false, "");                    start(mCurrPath);                    // todo 先隐藏添加水印功能                    // appendWatermark(mCurrPath);                    break;                case RecorderUtils.COMPRESS_FAILURE: // 压缩失败                    Log.e("xuan", "压缩失败" + mCurrPath);                    showWaitDialog(false, "");                    showToast(getString(R.string.compre_failure));                    start(mCurrPath);                    // todo 先隐藏添加水印功能                    // appendWatermark(mCurrPath);                    break;                case RecorderUtils.WATERMARK_SUCCESS: // 添加水印成功                    Log.e("xuan", "添加水印成功" + mCurrPath);                    start(mCurrPath);                    break;                case RecorderUtils.WATERMARK_FAILURE: // 添加水印失败                    Log.e("xuan", "添加水印失败" + mCurrPath);                    start(mCurrPath);                    break;                case RecorderUtils.MUSIC_SUCCESS: // 修改音乐成功                case RecorderUtils.SPEED_SUCCESS: // 变速成功                case RecorderUtils.VOLUME_SUCCESS: // 修改音量成功                    showWaitDialog(false, "");                    mVideoView.play(mCurrPath);                    break;                case RecorderUtils.MUSIC_FAILURE: // 修改音乐失败                case RecorderUtils.SPEED_FAILURE: // 变速失败                case RecorderUtils.VOLUME_FAILURE: // 修改音量失败                    showWaitDialog(false, "");                    showToast(getString(R.string.edit_failed));                default:                    mTvLoding.setText(mHitText + " " + msg.what + "%");                    break;            }            return false;        }    });    @Override    protected void onCreate(Bundle savedInstanceState) {        CutoutHelper.setWindowOut(getWindow());        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_previewx);        mVideoPath = getIntent().getStringExtra("file_path");        mCurrBgmName = getIntent().getStringExtra("music_name");        mCurrBgmId = getIntent().getStringExtra("music_id");        mCurrPath = mVideoPath;        File file = new File(mVideoPath);        if (!file.exists()) {            Log.e("xuan", "onCreate: 视频文件不存在");        }        Log.e("xuan", "onCreate: " + mVideoPath);        init();        broadcast();        // loadcover(mVideoPath);        // 该页面直接禁止侧滑        setSwipeBackEnable(false);    }    @Override    protected void onResume() {        super.onResume();        if (mVideoView != null                && (mVideoView.mCurrState == JCVideoPlayer.CURRENT_STATE_PAUSE)) {            if (FileUtil.isExist(mCurrPath)) {                mVideoView.play(mCurrPath);                progressbar.play(mVideoView.getCurrentProgress(), mVideoView.getDuration());            }        }    }    @Override    protected void onPause() {        super.onPause();        if (mVideoView != null) {            mVideoView.pause();        }    }    @Override    public void onBackPressed() {        if (mWaitDialog.getVisibility() == View.VISIBLE) {            return;        }        super.onBackPressed();    }    @Override    protected void onDestroy() {        super.onDestroy();        unregisterReceiver(closeReceiver);    }    private void broadcast() {        IntentFilter intentFilter = new IntentFilter();        intentFilter.addAction(MsgBroadcast.ACTION_MSG_CLOSE_TRILL);        registerReceiver(closeReceiver, intentFilter);    }    private void init() {        CutoutHelper.initCutoutHolderTop(getWindow(), findViewById(R.id.vCutoutHolder));        mVideoView = findViewById(R.id.x_video);        mWaitDialog = findViewById(R.id.ll_loding);        mTvLoding = findViewById(R.id.tv_loading);        mRlTop = findViewById(R.id.rl_control_top);        mRlBottom = findViewById(R.id.rl_control_bottom);        mSpeedBar = findViewById(R.id.bar_change);        mTvBgmName = findViewById(R.id.tv_bgname);        mVolumeBar = findViewById(R.id.bar_volume);        iv_thumb = findViewById(R.id.iv_thumb);        iv_thumb.setVisibility(View.GONE);        progressbar = findViewById(R.id.xpb_pro);        mVideoView.addOnJcvdListener(new OnJcvdListener() {            @Override            public void onPrepared() {                long length = mVideoView.getDuration();                if (mVideoView.mCurrState == JCVideoPlayer.CURRENT_STATE_PAUSE) {                    progressbar.play(mVideoView.getCurrentProgress(), mVideoView.getDuration());                } else {                    progressbar.play(0, mVideoView.getDuration());                }                if (loadCover == 0) {                    loadCover(mVideoView.mCurrUrl, length);                }            }            @Override            public void onCompletion() {                progressbar.clear();            }            @Override            public void onError() {            }            @Override            public void onPause() {                progressbar.cancelProgressTimer();            }            @Override            public void onReset() {            }        });        mAvatarImg = findViewById(R.id.iv_disc);        AvatarHelper.getInstance().displayAvatar(coreManager.getSelf().getUserId(), mAvatarImg, true);        findViewById(R.id.ll_music).setOnClickListener(this);        findViewById(R.id.ll_volume).setOnClickListener(this);        findViewById(R.id.ll_effect).setOnClickListener(this);        findViewById(R.id.ll_cover).setOnClickListener(this);        findViewById(R.id.ll_filter).setOnClickListener(this);        findViewById(R.id.ll_back).setOnClickListener(this);        findViewById(R.id.ll_next).setOnClickListener(this);        mWaitDialog.setOnClickListener(this);        mVideoView.play(mVideoPath);        mTvBgmName.setText(TextUtils.isEmpty(mCurrBgmName) ? getString(R.string.Original_Sound) : mCurrBgmName);        mSpeedBar.addOnChangeListener(select -> {            float speed = 0.5f + select * 0.25f;            Log.e("xuan", "init: 选择速度" + speed);            changeSpeed(speed);        });        mVolumeBar.addOnChangeListener(curr -> {            int vol = (int) ((curr - 50) / 10f * 3); // ( -15 - 15)范围            Log.e("xuan", "选择音量 Volume: " + vol);            changeVolume(vol);        });        mSelectDialog = new SelectMusicDialog(this, info -> {            if (!info.path.equals(mCurrBgmPath)) {                mCurrBgmPath = info.path;                mCurrBgmName = info.getName();                mTvBgmName.setText(info.getName() + "  " + info.getName() + "   " + info.getName());                changeMusic(mCurrBgmPath);            }        }, getToken(), getAppConfig().GET_MUSIC_LIST, getAppConfig().downloadUrl);        coverDialog = new SelectCoverDialog(this, new Xcoverbar.OnChangeListener() {            @Override            public void change(String curr) {                ImageLoadHelper.showImage(PreviewxActivity.this, curr, iv_thumb);            }            @Override            public void confirm(String curr) {                thumbPath = curr;                Log.e("xuan", "init: 选择封面" + curr);                iv_thumb.setVisibility(View.GONE);                mVideoView.play("");            }            @Override            public void cancel() {                iv_thumb.setVisibility(View.GONE);                mVideoView.play("");            }        });        mVolumeBar.setVisibility(View.GONE);        mSpeedBar.setVisibility(View.GONE);    }    @Override    public void onClick(View v) {        switch (v.getId()) {            case R.id.ll_back:                finish();                break;            case R.id.ll_next:                compressVideo();                break;            case R.id.ll_music:                mSelectDialog.show();                break;            case R.id.ll_volume:                mSpeedBar.setVisibility(View.GONE);                mVolumeBar.setVisibility(mVolumeBar.getVisibility() == View.VISIBLE ? View.GONE : View.VISIBLE);                break;            case R.id.ll_effect:                mVolumeBar.setVisibility(View.GONE);                mSpeedBar.setVisibility(mSpeedBar.getVisibility() == View.VISIBLE ? View.GONE : View.VISIBLE);                break;            case R.id.ll_cover:                if (loadCover == RecorderUtils.COVER_SUCCESS) {                    coverDialog.show(mCoverPath);                    mVideoView.pause();                    iv_thumb.setVisibility(View.VISIBLE);                } else if (loadCover == RecorderUtils.COVER_LOADING) {                    // loadCover = RecorderUtils.COVER_AUTOOPEN;                    ToastUtil.showToast(mContext, getString(R.string.tip_load_cover));                }                break;            case R.id.ll_filter:                // mFilterDialog.show();                showToast(getString(R.string.tip_functional_development));                break;        }    }    /**     * 加载封面     *     * @param inPath     * @param time     */    private void loadCover(String inPath, long time) {        final int coverCount = 8;        loadCover = RecorderUtils.COVER_LOADING;        // 帧提取器        String thumb = RecorderUtils.getThumb(inPath);        String out = RecorderUtils.getThumbPath(inPath);        String cmd = RecorderUtils.ffmpegFindThumbMultipleCmd(inPath, out, time / 1000f, coverCount);        EpEditor.execCmd(cmd, time, new OnEditorListener() {            @Override            public void onSuccess() {                mCoverPath = out;                mVideoView.mCurrState = JCVideoPlayer.CURRENT_STATE_NORMAL;                handler.sendEmptyMessage(RecorderUtils.COVER_SUCCESS);                Log.e("xuan", "FFmpeg_EpMedia:封面 获取成功" + out);            }            @Override            public void onFailure() {/*                loadCover = RecorderUtils.COVER_FAILURE;                handler.sendEmptyMessage(RecorderUtils.COVER_FAILURE);*/                Log.e("xuan", "FFmpeg_EpMedia:封面 获取失败--->" + mVideoView.getDuration());                /**                 * FFmpeg_EpMedia获取帧图片失败，我们在通过系统提供的api获取帧图片                 */                AsyncUtils.doAsync(this, (AsyncUtils.Function<AsyncUtils.AsyncContext<OnEditorListener>>) onEditorListenerAsyncContext -> {                    MediaMetadataRetriever mmr = new MediaMetadataRetriever();                    mmr.setDataSource(inPath);                    for (int i = 0; i < coverCount; i++) {                        // 取出  视频时长/当前张数取反 *1000 μs 的bitmap                        Bitmap frameBitmap = mmr.getFrameAtTime(mVideoView.getDuration() / (coverCount - i) * 1000); // unit is μs 1 ms = 1000 μs                        FileUtil.saveFileByBitmap(frameBitmap, thumb, RecorderUtils.getThumbPath(inPath, i + 1));                        if (i == coverCount - 1) {                            mmr.release();                        }                    }                    mCoverPath = out;                    mVideoView.mCurrState = JCVideoPlayer.CURRENT_STATE_NORMAL;                    handler.sendEmptyMessage(RecorderUtils.COVER_SUCCESS);                    Log.e("xuan", "FFmpeg_EpMedia:封面 获取成功" + out);                });            }            @Override            public void onProgress(float v) {                Log.e("xuan", "FFmpeg_EpMedia:封面中");            }        });    }    /**     * 压缩     */    private void compressVideo() {        showWaitDialog(true, getString(R.string.compressed));        final String out = RecorderUtils.getVideoFileByTime();        String[] cmd = RecorderUtils.ffmpegComprerssCmd(mCurrPath, out);        long duration = VideoUitls.getDuration(mCurrPath);        VideoCompressUtil.exec(cmd, duration, new OnEditorListener() {            public void onSuccess() {                mCurrPath = out;                handler.sendEmptyMessage(RecorderUtils.COMPRESS_SUCCESS);            }            public void onFailure() {                handler.sendEmptyMessage(RecorderUtils.COMPRESS_FAILURE);            }            public void onProgress(float progress) {                int pro = Math.round(progress * 100);                if (pro < 100) {                    handler.sendEmptyMessage(pro);                }                Log.e("xuan", "onProgress: 压缩中" + pro);            }        });    }    /**     * 添加音乐     *     * @param musicPath     */    private void changeMusic(final String musicPath) {        showWaitDialog(true, getString(R.string.modified));        final String outfilePath = RecorderUtils.getVideoFileByTime();        EpEditor.music(mCurrPath, musicPath, outfilePath, 0f, 1f, new OnEditorListener() {            @Override            public void onSuccess() {                mCurrPath = outfilePath;                mVideoPath = mCurrPath;                mVideoView.mCurrState = JCVideoPlayer.CURRENT_STATE_NORMAL;                handler.sendEmptyMessage(RecorderUtils.MUSIC_SUCCESS);            }            @Override            public void onFailure() {                handler.sendEmptyMessage(RecorderUtils.MUSIC_FAILURE);            }            @Override            public void onProgress(float progress) {                //这里获取处理进度                int pro = Math.max(Math.min(Math.round(progress * 100), 100), 0);                handler.sendEmptyMessage(pro);            }        });    }    /**     * 调整播放速度     *     * @param speed     */    private void changeSpeed(float speed) {        if (speed == 1) {            // todo 如果调整了音量，这里就又被还原了            mCurrPath = mVideoPath;            mVideoView.mCurrState = JCVideoPlayer.CURRENT_STATE_NORMAL;            handler.sendEmptyMessage(RecorderUtils.SPEED_SUCCESS);            return;        }        File file = new File(RecorderUtils.changeFileNameBySpeed(mVideoPath, speed));        mCurrPath = file.getAbsolutePath();        if (file.exists()) {            mVideoView.mCurrState = JCVideoPlayer.CURRENT_STATE_NORMAL;            mVideoView.play(file.getAbsolutePath());            return;        }        showWaitDialog(true, getString(R.string.modified));        // todo 如果调整了音量，这里就又被还原了,因为是使用的原视频路径变速，现在为先变速后调音量才正常        EpEditor.changePTS(mVideoPath, file.getAbsolutePath(), speed, EpEditor.PTS.ALL, new OnEditorListener() {            @Override            public void onSuccess() {                mVideoView.mCurrState = JCVideoPlayer.CURRENT_STATE_NORMAL;                handler.sendEmptyMessage(RecorderUtils.SPEED_SUCCESS);            }            @Override            public void onFailure() {                mCurrPath = mVideoPath;                handler.sendEmptyMessage(RecorderUtils.SPEED_FAILURE);            }            @Override            public void onProgress(float progress) {                int pro = Math.round(progress * 100);                if (pro <= 100) {                    handler.sendEmptyMessage(pro);                }            }        });    }    /**     * 调整音量大小     *     * @param volume     */    private void changeVolume(int volume) {        showWaitDialog(true, getString(R.string.modified));        mVideoView.stop();        final String out = RecorderUtils.changeFileName(mCurrPath, "vol");        String[] cmd = RecorderUtils.ffmpegVolumeCmd(mCurrPath, out, volume);        long duration = VideoUitls.getDuration(mCurrPath);        VideoCompressUtil.exec(cmd, duration, new OnEditorListener() {            public void onSuccess() {                mCurrPath = out;                mVideoView.mCurrState = JCVideoPlayer.CURRENT_STATE_NORMAL;                handler.sendEmptyMessage(RecorderUtils.VOLUME_SUCCESS);                Log.e("xuan", "onProgress: 修改声音成功" + out);            }            public void onFailure() {                handler.sendEmptyMessage(RecorderUtils.VOLUME_FAILURE);                Log.e("xuan", "onProgress: 修改声音失败");            }            public void onProgress(float progress) {                int pro = Math.max(Math.min(Math.round(progress * 100), 100), 0);                handler.sendEmptyMessage(pro);            }        });    }    /**     * 添加水印 暂不启用     *     * @param filePath     */    private void appendWatermark(String filePath) {        DialogHelper.showDefaulteMessageProgressDialog(mContext);        // 输出路径        String out = RecorderUtils.changeFileName(mVideoPath, "waterMark");        Bitmap bitmap = FastBlurUtil.drawableToBitmap(this.getResources().getDrawable(R.mipmap.ic_logo));        // 拼接logo        EpVideo epVideo = new EpVideo(filePath).addDraw(new EpDraw(FileUtil.getDesignationFilePath("app_logo", bitmap),                DisplayUtil.dip2px(mContext, 10), DisplayUtil.dip2px(mContext, 10),                DisplayUtil.dip2px(mContext, 20), DisplayUtil.dip2px(mContext, 20),                false));        EpEditor.exec(epVideo, new EpEditor.OutputOption(out), new OnEditorListener() {            @Override            public void onSuccess() {                DialogHelper.dismissProgressDialog();                mCurrPath = out;                handler.sendEmptyMessage(RecorderUtils.WATERMARK_SUCCESS);            }            @Override            public void onFailure() {                DialogHelper.dismissProgressDialog();                handler.sendEmptyMessage(RecorderUtils.WATERMARK_FAILURE);            }            @Override            public void onProgress(float v) {            }        });    }    /**     * 跳转到发布界面     */    private void start(String filePath) {        mVideoView.stop();        mVideoView.reset();        if (TextUtils.isEmpty(thumbPath)) {            if (TextUtils.isEmpty(mCoverPath)) {                thumbPath = RecorderUtils.saveThumbByStrote(filePath);            } else {                thumbPath = String.format(mCoverPath, 1);            }        }        Intent intent = new Intent(this, ReleasexActivity.class);        long length = mVideoView.getDuration();        intent.putExtra("video_path", filePath);        intent.putExtra("video_length", length);        intent.putExtra("video_thumb", thumbPath);        if (!TextUtils.isEmpty(mCurrBgmId)) {            intent.putExtra("music_id", mCurrBgmId);        }        startActivity(intent);        finish();    }    public void showWaitDialog(boolean show, String hit) {        mWaitDialog.setVisibility(show ? View.VISIBLE : View.INVISIBLE);        if (show) {            mHitText = hit;            mTvLoding.setText(hit + " 0%");        } else {            mTvLoding.setText("");// 隐藏时需要清空该text        }    }    public void showToast(String content) {        Toast.makeText(this, content, Toast.LENGTH_SHORT).show();    }}